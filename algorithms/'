const util = require('util')
class Node<T> {
  value: T;
  left: Node<T> | null = null;
  right: Node<T> | null = null;
  height: number;

  constructor(value: T) {
    this.value = value;
    this.left = null;
    this.right = null;
    this.height = 1;
  }


}

class BinarySearchTree<T> {
  root: Node<T> | null = null;
  balanced: boolean;

  constructor(balanced = true) {
    this.root = null;
    this.balanced = balanced;
  }

  getHeight(node: Node<T> | null): number {
    if (!node) {
      return 0;
    }
    return node.height;
  }

  getBalance(node: Node<T> | null): number {
    if (!node) {
      return 0;
    }
    return this.getHeight(node.left) - this.getHeight(node.right);
  }

  rightRotate(y: Node<T>): Node<T> | null {
    // console.log(`Rotate right on node, ${y.value}`);
    let x = y.left;
    if (!x) {
      return null;
    }
    let T2 = x.right;
    x.right = y;
    y.left = T2;
    y.height = 1 + Math.max(this.getHeight(y.left), this.getHeight(y.right))
    x.height = 1 + Math.max(this.getHeight(x.left), this.getHeight(x.right))
    return x;
  }

  leftRotate(x: Node<T>): Node<T> | null {
    // console.log(`Rotate left on node, ${x.value}`);
    let y = x.right;
    if (!y) {
      return null;
    }
    let T2 = y.left;
    y.left = x;
    x.right = T2;
    x.height = 1 + Math.max(this.getHeight(x.left), this.getHeight(x.right))
    y.height = 1 + Math.max(this.getHeight(y.left), this.getHeight(y.right))
    return y;
  }

  delete(data: T, node = this.root) {
    if (!node) {
      return node;
    }
    if (data < node.value) {
      node.left = this.delete(data, node.left);
    }
    else if (data > node.value) {
      node.right = this.delete(data, node.right);
    }
    else {
      if (!node.left) {
        let temp = node.right;
        node = null;
        return temp;
      }
      else if (!node.right) {
        let temp = node.left;
        node = null;
        return temp;
      }
      let temp = node.left;
      node = null;
      return temp;
    }
    if (!node) {
      return node;
    }
    node.height = 1 + Math.max(this.getHeight(node.left), this.getHeight(node.right));
    let balance = this.getBalance(node);

    if (balance > 1 && this.getBalance(node.left) >= 0) {
      return this.rightRotate(node);
    }
    if (balance < -1 && this.getBalance(node.right) > 0) {
      return this.leftRotate(node);
    }
    return node;
  }

  insert2(value: T): this {
    let newNode = new Node(value);
    if (!this.root) {
      this.root = newNode;
      return this;
    }
    let currNode = this.root;
    while (currNode) {
      // ignore duplicate values
      if (currNode.value && value === currNode.value) {
        return this;
      }
      // Look at left child
      if (currNode.value && value < currNode.value) {
        if (!currNode.left) {
          currNode.left = newNode;
          return this;
        }
        else {
          currNode = currNode.left;
        }
      }
      else {
        //look at right child
        if (!currNode.right) {
          currNode.right = newNode;
          return this;
        }
        else {
          currNode = currNode.right;
        }
      }
    }
    return this;
  }

  // This is the same as 'insert', but uses recursion
  insert(value: T) {
    let newNode = new Node(value);
    if (!this.root) {
      this.root = newNode;
      return true;
    }
    const insertHelper = (currNode: Node<T>, parentNode: Node<T> | null) => {

      if (currNode.value && value === currNode.value) {
        return null;
      }
      if (currNode.value && value < currNode.value) {
        if (!currNode.left) {
          currNode.left = newNode;
        }
        else {
          insertHelper(currNode.left, currNode);
        }
      }
      else {
        //look at right child
        if (!currNode.right) {
          currNode.right = newNode;
        }
        else {
          insertHelper(currNode.right, currNode);
        }
      }
      if (this.balanced) {
        this.insertBalance(currNode, parentNode);
      }
      return currNode;
    }
    return insertHelper(this.root, null);
  }

  insertBalance(node: Node<T>, parentNode: Node<T> | null) {
    // Update the balance factor and balance the tree
    node.height = 1 + Math.max(this.getHeight(node.left), this.getHeight(node.right))
    let balance = this.getBalance(node);

    // Balancing the tree
    // Left Left
    if (balance > 1 && this.getBalance(node.left) >= 0) {
      let rightRotNode = this.rightRotate(node);
      if (parentNode) {
        if (node === parentNode.left) {
          parentNode.left = rightRotNode;
        }
        else {
          parentNode.right = rightRotNode;
        }
      }
      else {
        // must be root node
        this.root = rightRotNode;
      }
      return rightRotNode;
    }
    // Left Right
    if (node.left && balance > 1 && this.getBalance(node.left) < 0) {
      node.left = this.leftRotate(node.left);
      let leftRotNode = this.rightRotate(node);
      if (parentNode) {
        if (node === parentNode.left) {
          parentNode.left = leftRotNode;
        }
        else {
          parentNode.right = leftRotNode;
        }
      }
      else {
        // must be root node
        this.root = leftRotNode;
      }
      return leftRotNode;
    }

    // Right Right
    if (balance < -1 && this.getBalance(node.right) <= 0) {
      let leftRotNode = this.leftRotate(node);
      if (parentNode) {
        if (node === parentNode.left) {
          parentNode.left = leftRotNode;
        }
        else {
          parentNode.right = leftRotNode;
        }
      }
      else {
        // must be root node
        this.root = leftRotNode;
      }
      return leftRotNode;
    }
    // Right Left
    if (node.right && balance < -1 && this.getBalance(node.left) > 0) {
      node.right = this.rightRotate(node.right);
      let rightRotNode = this.leftRotate(node);
      if (parentNode) {
        if (node === parentNode.left) {
          parentNode.left = rightRotNode;
        }
        else {
          parentNode.right = rightRotNode;
        }
      }
      else {
        // must be root node
        this.root = rightRotNode;
      }
      return rightRotNode;
    }
  }

  find(value: T): Node<T> | undefined {
    if (!this.root) {
      return undefined;
    }
    let current: Node<T> | null = this.root;
    while (current) {
      if (!current) {
        return undefined;
      }
      if (current.value && value < current.value) {
        current = current.left;
      }
      else if (current.value && value > current.value) {
        current = current.right;
      }
      else {
        return current;
      }
    }
    return undefined;
  }

  // find with recursion
  find2(value: T): Node<T> | undefined {
    if (!this.root) {
      return undefined;
    }
    let current: Node<T> = this.root;

    function findHelper(current: Node<T> | null): Node<T> | undefined {
      if (!current) {
        return undefined;
      }
      if (current.value && value < current.value) {
        return findHelper(current.left)
      }
      else if (current.value && value > current.value) {
        return findHelper(current.right)
      }
      else {
        return current;
      }
    }
    return findHelper(current);
  }

  find3(value: T): Node<T> | false {
    if (this.root === null) {
      return false;
    }
    let current: Node<T> | null = this.root;
    let found = false;
    while (current && !found) {
      if (current.value && value < current.value) {
        current = current.left;
      }
      else if (current.value && value > current.value) {
        current = current.right;
      }
      else {
        found = true;
      }
    }
    if (!found || !current) {
      return false;
    }
    return current;
  }

  findParent(value: T): Node<T> | null {
    if (!this.root) {
      return null;
    }
    let current: Node<T> = this.root;
    let currentParent: Node<T> | null = null;

    function findHelper(currentParent: Node<T> | null, current: Node<T> | null): Node<T> | null {
      if (!current) {
        return null;
      }
      if (current.value && value < current.value) {
        currentParent = current;
        return findHelper(currentParent, current.left)
      }
      else if (current.value && value > current.value) {
        currentParent = current;
        return findHelper(currentParent, current.right)
      }
      else {
        return currentParent;
      }
    }
    let parent = findHelper(currentParent, current);
    if (parent) {
      return parent;
    }
    return null;
  }

  remove(key: T, root = this.root): Node<T> | null {
    if (root === null) {
      return root;
    }
    if (key > root.value) {
      root.right = this.remove(key, root.right);
    }
    else if (key < root.value) {
      root.left = this.remove(key, root.left);
    }
    else {
      // Special case for deleting a root node with one or no children
      if (root === this.root) {
        if (!root.left && !root.right) {
          this.root = null;
          return this.root;
        }
        if (root.left && !root.right) {
          this.root = root.left;
          return this.root;
        }
        if (!root.left && root.right) {
          this.root = root.right;
          return this.root;
        }
      }
      if (!root.left) {
        return root.right;
      }
      else if (!root.right) {
        return root.left;
      }
      let cur = root.right;
      while (cur.left) {
        cur = cur.left;
      }
      root.value = cur.value;
      root.right = this.remove(root.value, root.right);
    }
    return root;
  }

  findSecondLargest(root = this.root) {
    if (!root) return;
    if (root.left === null && root.right === null) {
      return;
    }
    let count = 0;
    let result = null;

    function reverseInOrder(node: Node<T> | null) {
      if (!node) {
        return;
      }
      reverseInOrder(node.right);
      // Increment the count of visited nodes
      count++;
      // If count becomes 2, then this is
      // the second largest element
      if (count === 2) {
        result = node.value;
        return;
      }
      reverseInOrder(node.left);
    }
    // Start reverse inorder traversal
    reverseInOrder(root);

    return result;
  }

  minValue(node: Node<T>): Node<T> {
    let current = node;
    while (current && current.left) {
      current = current.left;
    }
    return current;
  }


  // A recursive alternative
  minValue2(node = this.root): Node<T> | undefined {
    if (!node) {
      return undefined;
    }
    if (!node.left) {
      return node;
    }
    return this.minValue2(node.left);
  }

  /**
   * Determines if a binary tree is height-balanced.
   * A height-balanced tree is defined as a tree where the depth of the two subtrees 
   * of every node never differs by more than 1.
   * 
   * @param root - The root node of the binary tree
   * @returns true if the tree is balanced, false otherwise
   */
  isBalanced(root = this.root): boolean {
    /**
     * Helper function that calculates the height of a subtree.
     * Returns -1 if the subtree is unbalanced, otherwise returns the actual height.
     * 
     * @param node - The current node being processed
     * @returns The height of the subtree if balanced, -1 if unbalanced
     */
    const calculateHeight = (node: Node<T> | null): number => {
      // Base case: empty node has height 0
      if (node === null) {
        return 0;
      }
      // Recursively calculate the height of left subtree
      const leftHeight: number = calculateHeight(node.left);
      // Recursively calculate the height of right subtree
      const rightHeight: number = calculateHeight(node.right);
      // Check if any subtree is unbalanced or if current node violates balance condition
      if (leftHeight === -1 || rightHeight === -1 || Math.abs(leftHeight - rightHeight) > 1) {
        return -1; // Propagate unbalanced state up the tree
      }
      // Return the height of current subtree (1 + maximum height of children)
      return 1 + Math.max(leftHeight, rightHeight);
    };
    // Tree is balanced if the helper function doesn't return -1
    return calculateHeight(root) !== -1;
  }

  print() {
    let currNode = this.root;
    if (currNode) {
      console.log(currNode.value);
    }
    else {
      return;
    }

    function printHelper(aNode: Node<T> | null) {
      if (!aNode) {
        return;
      }
      if (aNode.left) {
        console.log(aNode.left.value);
      }
      if (aNode.right) {
        console.log(aNode.right.value);
      }
      printHelper(aNode.left);
      printHelper(aNode.right);
    }
    printHelper(currNode);
  }

  printInOrder(node = this.root) {
    if (!node) {
      return;
    }
    this.printInOrder(node.left);
    console.log(node.value);
    this.printInOrder(node.right);
  }

  prettyPrint(node = this.root, prefix = '', isLeft = true): void {
    if (node === null) {
      return;
    }
    if (node.right !== null) {
      this.prettyPrint(node.right, `${prefix}${isLeft ? '│   ' : '    '}`, false);
    }
    console.log(`${prefix}${isLeft ? '└── ' : '┌── '}${node.value}`);
    if (node.left !== null) {
      this.prettyPrint(node.left, `${prefix}${isLeft ? '    ' : '│   '}`, true);
    }
  }
}

let binarySearchTree2 = new BinarySearchTree();
// Q is left heavy, and P is left heavy, so do a single right rotation
let leftLeft = ['Q', 'P', 'D']
// unbalanced leftLeft should look like this:
//
// └── Q
//     └── P
//         └── D
// balanced leftLeft looks like:
//
// │   ┌── Q
// └── P
//     └── D
//
let leftLeft2 = ['P', 'D', 'Q', 'C', 'L', 'B']
// unbalanced leftLeft2 is:
// │   ┌── Q
// └── P
//     │   ┌── L
//     └── D
//         └── C
//             └── B
//
// balanced leftLeft2 is:
// │       ┌── Q
// │   ┌── P
// │   │   └── L
// └── D
//     └── C
//         └── B
// rightRight is A - B - D, if unbalanced.
let rightRight = ['A', 'B', 'D']
// when balanced it should be:
// │   ┌── D
// └── B
//     └── A
let rightRight2 = ['B', 'A', 'D', 'E', 'C', 'F']
// Balanced version is :
// │       ┌── F
// │   ┌── E
// └── D
//     │   ┌── C
//     └── B
//         └── A
let leftRight = ['Q', 'E', 'K']
// │   ┌── Q
// └── K
//     └── E
let leftRight2 = ['K', 'E', 'Q', 'C', 'F'];
leftRight.forEach(letter => {
  binarySearchTree2.insert(letter);
})
binarySearchTree2.prettyPrint();
// let letters = ['C', 'B', 'E', 'A', 'D', 'H', 'G', 'F']
// let letters2 = ['B', 'E', 'G', 'F', 'P', 'I', 'K', 'M']
// let letters3 = ['C', 'F', 'G']
module.exports = { BinarySearchTree, Node };
